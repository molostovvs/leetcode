General:
[O(x), O(y)] where O(x) - time, O(y) - space
_ prefix means that i cope with the task, but there was a better solution
__ prefix means that i did not cope with the task myself

1480. Running Sum of 1d Array - 5min
__724. Find Pivot Index - 100 min (spied solution)
205. Isomorphic Strings - 25 min
392. Is Subsequence - 11 min
1523. Count Odd Numbers in an Interval Range - 15 min
1491. Average Salary Excluding the Minimum and Maximum Salary - 6 min
217. Contains Duplicate - 2 min
1. Two Sum - 5 min (another 10 min for O(n) solution)
__53. Maximum Subarray - 40 min (spied solution)
__21. Merge Two Sorted Lists - 50 min (spied solution)
206. Reverse Linked List - 83 min
__191. Number of 1 Bits - 20 min (googled library solution) - 80 min (watched youtube video for all possible solutions)
1281. Subtract the Product and Sum of Digits of an Integer - 16 min
88. Merge Sorted Array - 15 min / 35 min (youtube video for time O(n) and space O(1))
876. Middle of the Linked List - 8 min
_142. Linked List Cycle II - naive 8 min [time O(n), space O(n)] / 110 min (after several youtube videos) [time O(n), space O(1)]
976. Largest Perimeter Triangle - 20 min [time O(n + n*logn), space O(1)]
1779. Find Nearest Point That Has the Same X or Y Coordinate - 8 min [time O(n), space O(1)]
350. Intersection of Two Arrays II - 28 min [time O(n*m^2?), space O(m)] / 40 min (after googling) this algorithm is better for sorted arrays [time O(n*logn + m*logm), space O(sorting)] and when sorted [time O(n + m), space O(1)] / 40 min (after spying another solutions) [time O(n+m), space O(n)]
121. Best Time to Buy and Sell Stock - 100 min [time O(n), space O(1)] / 10 min (for optimized variables) [time O(n), space O(1)]
409. Longest Palindrome - 25 min [time O(n), space O(1)]
1822. Sign of the Product of an Array - 13 min [O(n), O(1)]
1502. Can Make Arithmetic Progression From Sequence - 4 min [O(nlogn + n), O(sorting)]
_202. Happy Number - 20 min [O(log n), O(log n)] / 55 min [O(log n), O(1)]
1790. Check if One String Swap Can Make Strings Equal - 25 min [O(n), O(1)] / 12 min (checked solution without list) [O(n), O(1)]
566. Reshape the Matrix - 35 min [O(n*m), O(1)]
118. Pascal's Triangle - 45 min [O(n^2), O(n^2)]
589. N-ary Tree Preorder Traversal - 10 min for recursive algorithm [O(n), O(1)] / 40 min for iterative algorithm with linked list[O(n), O(n)] / 5 min for iterative with stack (after viewing the solution) [O(n), O(n)]
102. Binary Tree Level Order Traversal - 15 min [O(n), O(n)]
_496. Next Greater Element I - 15 min brute force [O(n + m*m), O(1)] / 50 min (spied) for [O(n+m), O(n)]
1232. Check If It Is a Straight Line - 40 min [O(n), O(1)]
36. Valid Sudoku - 40 min [O(n?), O(n)]
74. Search a 2D Matrix - 60 min [O(log (n*m)), O(1)]
__704. Binary Search - 30 min (googled) [O(log n), O(1)]
278. First Bad Version - 10 min [O(log n), O(1)]
387. First Unique Character in a String - 20 min [O(n), O(1)]
383. Ransom Note - 5 min [O(logn), O(1)]
_242. Valid Anagram - 8 min [O(n+m), O(n+m)] / 30 min (googled) [O(slog s + tlog t), O(1)]
__1588. Sum of All Odd Length Subarrays - 40 min (googled) [O(n), O(1)]
283. Move Zeroes - 20 min [O(n), O(1)] / 20 min - less code (googled) [O(n), O(1)]
1672. Richest Customer Wealth - 2 min [O(n), O(1)]
__974. Subarray Sums Divisible by K - 70 min (googled) [O(n), O(n)]
__98. Validate Binary Search Tree - 90 min [O(n), O(1)]
235. Lowest Common Ancestor of a Binary Search Tree - 30 min [O(n+h), O(n+h)] / 20 min (googled) [O(logn), O(1)]
1572. Matrix Diagonal Sum - 10 min [O(n), O(1)]
141. Linked List Cycle - 10 min [O(n), O(1)]
21. Merge Two Sorted Lists - 10 min [O(n + m), O(1)]
__203. Remove Linked List Elements - 80 min [O(n), O(1)]
